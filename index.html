<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSP Similarity Analysis Visualization</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 30px;
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        
        .value-display {
            font-size: 14px;
            color: #777;
            text-align: center;
        }
        
        .range-container {
            position: relative;
            width: 100%;
            height: 27.5px;
            display: flex;
            align-items: center;
        }
        
        .range-track {
            position: relative;
            width: 100%;
            height: 6px;
            background: #ddd;
            border-radius: 3px;
        }
        
        .range-fill {
            position: absolute;
            height: 100%;
            background: #007bff;
            border-radius: 3px;
            pointer-events: none;
        }
        
        .range-slider {
            position: absolute;
            width: 100%;
            height: 20px;
            background: transparent;
            pointer-events: none;
            -webkit-appearance: none;
            appearance: none;
            top: -12px;
            left: 0;
            margin: 0;
        }
        
        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            cursor: pointer;
            pointer-events: auto;
        }
        
        .range-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            cursor: pointer;
            pointer-events: auto;
        }
        
        .range-slider::-webkit-slider-track {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: transparent;
            border-radius: 3px;
        }
        
        .range-slider::-moz-range-track {
            height: 6px;
            background: transparent;
            border-radius: 3px;
            border: none;
        }
        
        .chart-container {
            position: relative;
            height: 500px;
            margin-top: 20px;
        }
        
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 0;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        .info {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            border-left: 4px solid #007bff;
        }
        
        .computing {
            color: #ff6b35;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>SSP Similarity Analysis Visualization</h1>
        
        <div class="info">
            <strong>About:</strong> This visualization analyzes how dot products and cosine similarities change when 
            Spatial Semantic Pointers (SSPs) are raised to different powers. Adjust the parameters below to see 
            real-time changes in the similarity patterns.
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="dimensions">Dimensions (D)</label>
                <input type="range" id="dimensions" min="3" max="1000" value="50" step="1">
                <div class="value-display" id="dimensionsValue">50</div>
            </div>
            
            <div class="control-group">
                <label for="exponentRange">Exponent Range</label>
                <div class="range-container">
                    <div class="range-track">
                        <div class="range-fill" id="rangeFill"></div>
                        <input type="range" id="exponentMin" min="-100" max="100" value="-9" step="1" class="range-slider">
                        <input type="range" id="exponentMax" min="-100" max="100" value="11" step="1" class="range-slider">
                    </div>
                </div>
                <div class="value-display" id="exponentRangeValue">-9 to 11</div>
            </div>
            
            <div class="control-group">
                <label for="numPoints">Number of Points</label>
                <input type="range" id="numPoints" min="20" max="1000" value="100" step="10">
                <div class="value-display" id="numPointsValue">100</div>
            </div>
        </div>
        
        <button id="newSSPButton" onclick="generateNewSSP()" style="margin: 10px 0;">New SSP</button>
        
        <div id="status"></div>
        
        <div class="chart-container">
            <canvas id="similarityChart"></canvas>
        </div>
    </div>

    <script>
        // Global variables
        let chart = null;
        let isComputing = false;
        let cachedSSP = null;
        let cachedDimensions = null;

        // Complex number operations
        class Complex {
            constructor(real, imag = 0) {
                this.real = real;
                this.imag = imag;
            }
            
            add(other) {
                return new Complex(this.real + other.real, this.imag + other.imag);
            }
            
            subtract(other) {
                return new Complex(this.real - other.real, this.imag - other.imag);
            }
            
            multiply(other) {
                if (typeof other === 'number') {
                    return new Complex(this.real * other, this.imag * other);
                }
                return new Complex(
                    this.real * other.real - this.imag * other.imag,
                    this.real * other.imag + this.imag * other.real
                );
            }
            
            conjugate() {
                return new Complex(this.real, -this.imag);
            }
            
            magnitude() {
                return Math.sqrt(this.real * this.real + this.imag * this.imag);
            }
            
            power(exponent) {
                if (exponent === 0) return new Complex(1, 0);
                if (exponent === 1) return new Complex(this.real, this.imag);
                
                const magnitude = this.magnitude();
                const phase = Math.atan2(this.imag, this.real);
                
                const newMagnitude = Math.pow(magnitude, exponent);
                const newPhase = phase * exponent;
                
                return new Complex(
                    newMagnitude * Math.cos(newPhase),
                    newMagnitude * Math.sin(newPhase)
                );
            }
        }

        // FFT Implementation
        function customFFT(x) {
            const N = x.length;
            
            if (N <= 1) return x;
            
            // If not a power of 2, use direct DFT
            if ((N & (N - 1)) !== 0) {
                return directDFT(x);
            }
            
            // Cooley-Tukey FFT for power-of-2 lengths
            const even = [];
            const odd = [];
            
            for (let i = 0; i < N; i += 2) {
                even.push(x[i]);
                if (i + 1 < N) odd.push(x[i + 1]);
            }
            
            const evenFFT = customFFT(even);
            const oddFFT = customFFT(odd);
            
            const result = new Array(N);
            const halfN = N / 2;
            
            for (let k = 0; k < halfN; k++) {
                const t = new Complex(Math.cos(-2 * Math.PI * k / N), Math.sin(-2 * Math.PI * k / N)).multiply(oddFFT[k]);
                result[k] = evenFFT[k].add(t);
                result[k + halfN] = evenFFT[k].subtract(t);
            }
            
            return result;
        }
        
        function directDFT(x) {
            const N = x.length;
            const result = new Array(N);
            
            for (let k = 0; k < N; k++) {
                result[k] = new Complex(0, 0);
                for (let n = 0; n < N; n++) {
                    const angle = -2 * Math.PI * k * n / N;
                    const twiddle = new Complex(Math.cos(angle), Math.sin(angle));
                    result[k] = result[k].add(x[n].multiply(twiddle));
                }
            }
            
            return result;
        }
        
        function customIFFT(x) {
            const N = x.length;
            const conjugated = x.map(c => c.conjugate());
            const fftResult = customFFT(conjugated);
            return fftResult.map(c => c.conjugate().multiply(1 / N));
        }

        // Generate unitary SSP
        function makeGoodUnitary(D, eps = 1e-3) {
            const halfD = Math.floor((D - 1) / 2);
            const a = new Array(halfD);
            const phi = new Array(halfD);
            
            for (let i = 0; i < halfD; i++) {
                a[i] = Math.random();
                const sign = Math.random() < 0.5 ? -1 : 1;
                phi[i] = sign * Math.PI * (eps + a[i] * (1 - 2 * eps));
            }
            
            const fv = new Array(D);
            for (let i = 0; i < D; i++) {
                fv[i] = new Complex(0, 0);
            }
            
            fv[0] = new Complex(1, 0);
            
            for (let i = 1; i <= halfD; i++) {
                fv[i] = new Complex(Math.cos(phi[i-1]), Math.sin(phi[i-1]));
            }
            
            for (let i = 1; i <= halfD; i++) {
                fv[D - i] = fv[i].conjugate();
            }
            
            if (D % 2 === 0) {
                fv[D / 2] = new Complex(1, 0);
            }
            
            const v = customIFFT(fv);
            return v.map(c => c.real);
        }

        // Power SSP
        function powerSSP(ssp, exponent) {
            const sspComplex = ssp.map(x => new Complex(x, 0));
            const sspFFT = customFFT(sspComplex);
            const sspPowered = sspFFT.map(c => c.power(exponent));
            const sspPoweredReal = customIFFT(sspPowered);
            return sspPoweredReal.map(c => c.real);
        }

        // Vector operations
        function dotProduct(a, b) {
            return a.reduce((sum, val, i) => sum + val * b[i], 0);
        }
        
        function norm(v) {
            return Math.sqrt(v.reduce((sum, val) => sum + val * val, 0));
        }
        
        function cosineSimilarity(a, b) {
            return dotProduct(a, b) / (norm(a) * norm(b));
        }

        // Linear space function
        function linspace(start, end, num) {
            const result = [];
            const step = (end - start) / (num - 1);
            for (let i = 0; i < num; i++) {
                result.push(start + i * step);
            }
            return result;
        }

        // Main analysis function
        async function analyzeSSPSimilarity(N, D, minExp, maxExp, numPoints) {
            const exponents = linspace(minExp, maxExp, numPoints);
            
            // Generate N unitary SSPs (only if dimensions changed)
            const ssps = [];
            if (cachedSSP === null || cachedDimensions !== D) {
                for (let i = 0; i < N; i++) {
                    ssps.push(makeGoodUnitary(D));
                }
                cachedSSP = ssps[0]; // Cache the SSP
                cachedDimensions = D;
            } else {
                ssps.push(cachedSSP); // Use cached SSP
            }
            
            const averageDotProducts = [];
            const averageCosineSimilarities = [];
            const sspNorms = [];
            const sspMeans = [];
            const sspStds = [];
            
            // Compute norms of original SSPs
            const normsOriginal = ssps.map(ssp => norm(ssp));
            
            for (let i = 0; i < exponents.length; i++) {
                const exponent = exponents[i];
                
                // Show progress
                // if (i % Math.floor(numPoints / 10) === 0) {
                //     document.getElementById('status').innerHTML = 
                //         `<span class="computing">Computing... ${Math.round(i / numPoints * 100)}%</span>`;
                //     await new Promise(resolve => setTimeout(resolve, 1));
                // }
                
                // Power each SSP
                const sspsPowered = ssps.map(ssp => powerSSP(ssp, exponent));
                
                // Compute dot products and cosine similarities
                const dotProducts = [];
                const cosineSimilarities = [];
                const poweredNorms = [];
                const poweredMeans = [];
                const poweredStds = [];
                
                for (let j = 0; j < N; j++) {
                    const dotProd = dotProduct(ssps[j], sspsPowered[j]);
                    const normPowered = norm(sspsPowered[j]);
                    const cosSim = dotProd / (normsOriginal[j] * normPowered);
                    
                    dotProducts.push(dotProd);
                    cosineSimilarities.push(cosSim);
                    poweredNorms.push(normPowered);
                    poweredMeans.push(sspsPowered[j].reduce((sum, val) => sum + val, 0) / sspsPowered[j].length);
                    poweredStds.push(Math.sqrt(sspsPowered[j].reduce((sum, val) => sum + (val - poweredMeans[j]) ** 2, 0) / sspsPowered[j].length));
                }
                
                // Compute averages
                const avgDotProduct = dotProducts.reduce((sum, val) => sum + val, 0) / N;
                const avgCosineSimilarity = cosineSimilarities.reduce((sum, val) => sum + val, 0) / N;
                const avgNorm = poweredNorms.reduce((sum, val) => sum + val, 0) / N;
                const avgMean = poweredMeans.reduce((sum, val) => sum + val, 0) / N;
                const avgStd = poweredStds.reduce((sum, val) => sum + val, 0) / N;
                
                averageDotProducts.push(avgDotProduct);
                averageCosineSimilarities.push(avgCosineSimilarity);
                sspNorms.push(avgNorm);
                sspMeans.push(avgMean);
                sspStds.push(avgStd);
            }
            
            // document.getElementById('status').innerHTML = '';
            
            return {
                exponents: exponents,
                dotProducts: averageDotProducts,
                cosineSimilarities: averageCosineSimilarities,
                sspNorms: sspNorms,
                sspMeans: sspMeans,
                sspStds: sspStds
            };
        }

        // Chart initialization and update
        function initChart() {
            const ctx = document.getElementById('similarityChart').getContext('2d');
            
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Dot Product',
                            data: [],
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.1
                        },
                        {
                            label: 'Cosine Similarity',
                            data: [],
                            borderColor: 'rgb(255, 99, 132)',
                            backgroundColor: 'rgba(255, 99, 132, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.1
                        },
                        {
                            label: 'Norm',
                            data: [],
                            borderColor: 'rgb(54, 162, 235)',
                            backgroundColor: 'rgba(54, 162, 235, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.1,
                            hidden: true
                        },
                        {
                            label: 'Mean',
                            data: [],
                            borderColor: 'rgb(255, 159, 64)',
                            backgroundColor: 'rgba(255, 159, 64, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.1,
                            hidden: true
                        },
                        {
                            label: 'Standard Deviation',
                            data: [],
                            borderColor: 'rgb(153, 102, 255)',
                            backgroundColor: 'rgba(153, 102, 255, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.1,
                            hidden: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    // Add padding on the right to ensure the last x-axis tick label is not clipped
                    layout: {
                        padding: {
                            right: 20 // px
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'SSP Analysis vs. Exponent'
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Exponent'
                            },
                            ticks: {
                                autoSkip: false,
                                callback: function(value, index, values) {
                                    const minExp = parseFloat(document.getElementById('exponentMin').value);
                                    const maxExp = parseFloat(document.getElementById('exponentMax').value);
                                    
                                    // Show min, max, and 1 (if in range)
                                    if (index === 0) return minExp.toFixed(1);
                                    if (index === values.length - 1) return maxExp.toFixed(1);
                                    
                                    // Find if 1 is in the range and show it
                                    const step = (maxExp - minExp) / (values.length - 1);
                                    const currentValue = minExp + index * step;

                                    // Decide which single tick (if any) should show the label "1".
                                    if (1 > minExp && 1 < maxExp) {
                                        const nearestIndex = Math.round((1 - minExp) / step);
                                        if (index === nearestIndex) {
                                            return '1';
                                        }
                                    }
                                    
                                    return '';
                                }
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Value'
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });
        }

        // Update visualization
        async function updateVisualization() {
            if (isComputing) return;
            
            isComputing = true;
            
            const N = 1;
            const D = parseInt(document.getElementById('dimensions').value);
            const minExp = parseFloat(document.getElementById('exponentMin').value);
            const maxExp = parseFloat(document.getElementById('exponentMax').value);
            const numPoints = parseInt(document.getElementById('numPoints').value);
            
            try {
                const results = await analyzeSSPSimilarity(N, D, minExp, maxExp, numPoints);
                
                // Update similarity chart
                chart.data.labels = results.exponents.map(x => x.toFixed(2));
                chart.data.datasets[0].data = results.dotProducts;
                chart.data.datasets[1].data = results.cosineSimilarities;
                chart.data.datasets[2].data = results.sspNorms;
                chart.data.datasets[3].data = results.sspMeans;
                chart.data.datasets[4].data = results.sspStds;
                chart.update();
                
            } catch (error) {
                console.error('Error during analysis:', error);
                document.getElementById('status').innerHTML = 
                    '<span style="color: red;">Error during computation. Check console for details.</span>';
            }
            
            isComputing = false;
        }

        // Update slider value displays
        function updateSliderValues() {
            document.getElementById('dimensionsValue').textContent = 
                document.getElementById('dimensions').value;
            document.getElementById('exponentRangeValue').textContent = 
                document.getElementById('exponentMin').value + ' to ' + document.getElementById('exponentMax').value;
            document.getElementById('numPointsValue').textContent = 
                document.getElementById('numPoints').value;
        }

        // Handle range slider logic
        function handleRangeSlider() {
            const minSlider = document.getElementById('exponentMin');
            const maxSlider = document.getElementById('exponentMax');
            const rangeFill = document.getElementById('rangeFill');
            const minVal = parseInt(minSlider.value);
            const maxVal = parseInt(maxSlider.value);
            
            // Ensure min doesn't exceed max
            if (minVal > maxVal) {
                if (this === minSlider) {
                    maxSlider.value = minVal;
                } else {
                    minSlider.value = maxVal;
                }
            }
            
            // Update visual fill
            const range = 200; // -100 to 100
            const minPercent = ((minVal + 100) / range) * 100;
            const maxPercent = ((maxVal + 100) / range) * 100;
            
            rangeFill.style.left = minPercent + '%';
            rangeFill.style.width = (maxPercent - minPercent) + '%';
            
            updateSliderValues();
            debouncedUpdate();
        }

        // Generate new SSP
        function generateNewSSP() {
            cachedSSP = null;
            cachedDimensions = null;
            updateVisualization();
        }

        // Debounce function to prevent too frequent updates
        let updateTimeout = null;
        function debouncedUpdate() {
            if (updateTimeout) {
                clearTimeout(updateTimeout);
            }
            updateTimeout = setTimeout(() => {
                updateVisualization();
            }, 300); // 300ms delay
        }

        // Initialize everything
        document.addEventListener('DOMContentLoaded', function() {
            initChart();
            updateSliderValues();
            
            // Initialize range slider visual
            handleRangeSlider();
            
            // Add event listeners to sliders with automatic updates
            const sliders = ['dimensions', 'numPoints'];
            sliders.forEach(id => {
                document.getElementById(id).addEventListener('input', function() {
                    updateSliderValues();
                    debouncedUpdate();
                });
            });
            
            // Add event listeners for range sliders
            document.getElementById('exponentMin').addEventListener('input', handleRangeSlider);
            document.getElementById('exponentMax').addEventListener('input', handleRangeSlider);
            
            // Initial visualization
            updateVisualization();
        });
    </script>
</body>
</html> 