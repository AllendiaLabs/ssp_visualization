<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spatial Semantic Pointer Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        .content-wrapper {
            border-radius: 15px;
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .header p {
            margin: 10px 0 0 0;
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .controls {
            background: #f8f9fa;
            padding: 25px;
            border-bottom: 1px solid #e9ecef;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-radius: 15px 15px 0 0;
            margin-top: -1px;
        }
        
        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            align-items: center;
            justify-content: center;
        }
        
        .control {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 200px;
        }
        
        .control label {
            font-weight: bold;
            margin-bottom: 8px;
            color: #495057;
        }
        
        .control input[type="range"] {
            width: 200px;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        
        .control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }
        
        .control input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            border: none;
        }
        
        .control .value {
            margin-top: 5px;
            font-size: 14px;
            color: #6c757d;
            font-weight: bold;
        }
        
        .visualizations {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 30px;
            padding: 30px;
        }
        
        .viz-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.07);
            border: 1px solid #e9ecef;
        }
        
        .viz-title {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #495057;
            text-align: center;
        }
        
        #threejs-container {
            width: 100%;
            height: 400px;
            border-radius: 8px;
            overflow: hidden;
            background: #f8f9fa;
        }
        
        canvas {
            border-radius: 8px;
        }
        
        .chart-container {
            position: relative;
            height: 400px;
            width: 100%;
        }
        
        .stats {
            background: #e9ecef;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-family: monospace;
            font-size: 12px;
        }
        
        .stats-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        
        @media (max-width: 768px) {
            .visualizations {
                grid-template-columns: 1fr;
            }
            
            .control-group {
                flex-direction: column;
                gap: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="content-wrapper">
            <div class="header">
                <h1>Spatial Semantic Pointer Visualization</h1>
                <p>Interactive exploration of SSP transformations and similarity analysis</p>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <div class="control">
                    <label for="exponent">Exponent</label>
                    <input type="range" id="exponent" min="-10" max="10" step="0.1" value="0">
                    <div class="value" id="exponent-value">0.0</div>
                </div>
                
                <div class="control">
                    <label for="dimension">SSP Dimension</label>
                    <input type="range" id="dimension" min="3" max="50" step="1" value="10">
                    <div class="value" id="dimension-value">10</div>
                </div>
                
                <div class="control">
                    <label for="similarity-range">Similarity Range</label>
                    <input type="range" id="similarity-range" min="5" max="100" step="5" value="50">
                    <div class="value" id="similarity-range-value">±50</div>
                </div>
                
                <div class="control">
                    <label for="animation-speed">Animation Speed</label>
                    <input type="range" id="animation-speed" min="0.1" max="2" step="0.1" value="1">
                    <div class="value" id="animation-speed-value">1.0x</div>
                </div>
            </div>
        </div>
        
        <div class="content-wrapper">
            <div class="visualizations">
                <div class="viz-container">
                    <div class="viz-title">3D SSP Trajectory</div>
                    <div id="threejs-container"></div>
                    <div class="stats" id="stats-3d">
                        <div class="stats-row">
                            <span>Norm:</span>
                            <span id="norm-value">1.000</span>
                        </div>
                        <div class="stats-row">
                            <span>Mean:</span>
                            <span id="mean-value">0.000</span>
                        </div>
                        <div class="stats-row">
                            <span>Std:</span>
                            <span id="std-value">0.316</span>
                        </div>
                    </div>
                </div>
                
                <div class="viz-container">
                    <div class="viz-title">Parallel Coordinates</div>
                    <div class="chart-container">
                        <canvas id="parallel-chart"></canvas>
                    </div>
                </div>
                
                <div class="viz-container">
                    <div class="viz-title">Similarity Analysis</div>
                    <div class="chart-container">
                        <canvas id="similarity-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Proper SSP implementation with FFT-based exponentiation
        class SSPUtils {
            static makeGoodUnitary(D, eps = 1e-3) {
                // Generate proper unitary SSP following the Python implementation
                const a = [];
                for (let i = 0; i < Math.floor((D - 1) / 2); i++) {
                    a.push(Math.random());
                }
                
                const phi = a.map(() => {
                    const sign = Math.random() < 0.5 ? -1 : 1;
                    return sign * Math.PI * (eps + Math.random() * (1 - 2 * eps));
                });
                
                // Create frequency domain representation
                const fv = new Array(D);
                for (let i = 0; i < D; i++) {
                    fv[i] = {real: 0, imag: 0};
                }
                
                fv[0] = {real: 1, imag: 0};
                
                for (let i = 0; i < phi.length; i++) {
                    fv[i + 1] = {
                        real: Math.cos(phi[i]),
                        imag: Math.sin(phi[i])
                    };
                }
                
                // Conjugate symmetry
                for (let i = 1; i <= Math.floor(D / 2); i++) {
                    if (D - i > 0 && D - i < D) {
                        fv[D - i] = {
                            real: fv[i].real,
                            imag: -fv[i].imag
                        };
                    }
                }
                
                if (D % 2 === 0) {
                    fv[D / 2] = {real: 1, imag: 0};
                }
                
                // IFFT to get time domain
                const v = this.ifft(fv);
                return v.map(x => x.real);
            }
            
            static powerSSP(ssp, exponent) {
                // Proper SSP exponentiation in frequency domain
                // Step 1: FFT of the SSP
                const ssp_complex = ssp.map(x => ({real: x, imag: 0}));
                const ssp_fft = this.fft(ssp_complex);
                
                // Step 2: Raise each frequency component to the power
                const ssp_pow_fft = ssp_fft.map(c => {
                    // Complex exponentiation: z^n = r^n * e^(in*θ)
                    const magnitude = Math.sqrt(c.real * c.real + c.imag * c.imag);
                    const phase = Math.atan2(c.imag, c.real);
                    
                    const new_magnitude = Math.pow(magnitude, exponent);
                    const new_phase = phase * exponent;
                    
                    return {
                        real: new_magnitude * Math.cos(new_phase),
                        imag: new_magnitude * Math.sin(new_phase)
                    };
                });
                
                // Step 3: IFFT back to time domain
                const ssp_pow = this.ifft(ssp_pow_fft);
                return ssp_pow.map(x => x.real);
            }
            
            static fft(x) {
                const N = x.length;
                if (N <= 1) return x;
                
                // Ensure power of 2
                if ((N & (N - 1)) !== 0) {
                    // Pad to next power of 2
                    const nextPow2 = Math.pow(2, Math.ceil(Math.log2(N)));
                    const padded = [...x];
                    while (padded.length < nextPow2) {
                        padded.push({real: 0, imag: 0});
                    }
                    const result = this.fft(padded);
                    return result.slice(0, N);
                }
                
                // Bit-reversal permutation
                const result = new Array(N);
                for (let i = 0; i < N; i++) {
                    let j = 0;
                    let temp = i;
                    for (let k = 0; k < Math.log2(N); k++) {
                        j = (j << 1) | (temp & 1);
                        temp >>= 1;
                    }
                    result[j] = {...x[i]};
                }
                
                // Cooley-Tukey FFT
                for (let len = 2; len <= N; len *= 2) {
                    const angle = -2 * Math.PI / len;
                    const wlen = {real: Math.cos(angle), imag: Math.sin(angle)};
                    
                    for (let i = 0; i < N; i += len) {
                        let w = {real: 1, imag: 0};
                        for (let j = 0; j < len / 2; j++) {
                            const even = result[i + j];
                            const odd_idx = i + j + len / 2;
                            
                            // Complex multiplication: w * result[odd_idx]
                            const odd = {
                                real: result[odd_idx].real * w.real - result[odd_idx].imag * w.imag,
                                imag: result[odd_idx].real * w.imag + result[odd_idx].imag * w.real
                            };
                            
                            result[i + j] = {
                                real: even.real + odd.real,
                                imag: even.imag + odd.imag
                            };
                            result[i + j + len / 2] = {
                                real: even.real - odd.real,
                                imag: even.imag - odd.imag
                            };
                            
                            // Update w = w * wlen
                            const temp_w = {
                                real: w.real * wlen.real - w.imag * wlen.imag,
                                imag: w.real * wlen.imag + w.imag * wlen.real
                            };
                            w = temp_w;
                        }
                    }
                }
                
                return result;
            }
            
            static ifft(x) {
                // Conjugate input
                const conj = x.map(c => ({real: c.real, imag: -c.imag}));
                
                // FFT
                const result = this.fft(conj);
                
                // Conjugate and scale
                return result.map(c => ({
                    real: c.real / x.length,
                    imag: -c.imag / x.length
                }));
            }
            
            static norm(vec) {
                return Math.sqrt(vec.reduce((sum, x) => sum + x * x, 0));
            }
            
            static mean(vec) {
                return vec.reduce((sum, x) => sum + x, 0) / vec.length;
            }
            
            static std(vec) {
                const m = this.mean(vec);
                const variance = vec.reduce((sum, x) => sum + (x - m) * (x - m), 0) / vec.length;
                return Math.sqrt(variance);
            }
            
            static dotProduct(a, b) {
                return a.reduce((sum, x, i) => sum + x * b[i], 0);
            }
            
            static cosineSimilarity(a, b) {
                const dot = this.dotProduct(a, b);
                const normA = this.norm(a);
                const normB = this.norm(b);
                return dot / (normA * normB);
            }
        }
        
        // Global state
        let currentSSP = null;
        let currentDimension = 10;
        let animationSpeed = 1.0;
        let animationTime = 0;
        let isAnimating = true;
        
        // Components
        let scene, camera, renderer, currentPoint, connectionLine, allPoints;
        let parallelChart, similarityChart;
        
        function init() {
            console.log("Starting initialization...");
            setupControls();
            setupThreeJS();
            setupCharts();
            generateNewSSP();
            animate();
        }
        
        function setupControls() {
            const exponentSlider = document.getElementById('exponent');
            const dimensionSlider = document.getElementById('dimension');
            const similarityRangeSlider = document.getElementById('similarity-range');
            const animationSpeedSlider = document.getElementById('animation-speed');
            
            const exponentValue = document.getElementById('exponent-value');
            const dimensionValue = document.getElementById('dimension-value');
            const similarityRangeValue = document.getElementById('similarity-range-value');
            const animationSpeedValue = document.getElementById('animation-speed-value');
            
            // Initialize
            currentDimension = parseInt(dimensionSlider.value);
            animationSpeed = parseFloat(animationSpeedSlider.value);
            
            // Display initial values
            exponentValue.textContent = parseFloat(exponentSlider.value).toFixed(1);
            dimensionValue.textContent = dimensionSlider.value;
            similarityRangeValue.textContent = `±${similarityRangeSlider.value}`;
            animationSpeedValue.textContent = `${animationSpeedSlider.value}x`;
            
            // Event listeners
            exponentSlider.addEventListener('input', (e) => {
                exponentValue.textContent = parseFloat(e.target.value).toFixed(1);
                isAnimating = false;
            });
            
            dimensionSlider.addEventListener('input', (e) => {
                dimensionValue.textContent = e.target.value;
                currentDimension = parseInt(e.target.value);
                generateNewSSP();
            });
            
            similarityRangeSlider.addEventListener('input', (e) => {
                similarityRangeValue.textContent = `±${e.target.value}`;
                updateSimilarityChart();
            });
            
            animationSpeedSlider.addEventListener('input', (e) => {
                animationSpeedValue.textContent = `${e.target.value}x`;
                animationSpeed = parseFloat(e.target.value);
                isAnimating = true;
            });
        }
        
        function setupThreeJS() {
            const container = document.getElementById('threejs-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f9fa);
            
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(2, 2, 2);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            setupCameraControls();
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            // Axes
            const axesHelper = new THREE.AxesHelper(1);
            scene.add(axesHelper);
            
            // Current point
            const currentGeometry = new THREE.SphereGeometry(0.05, 16, 16);
            const currentMaterial = new THREE.MeshLambertMaterial({ color: 0x4CAF50 });
            currentPoint = new THREE.Mesh(currentGeometry, currentMaterial);
            scene.add(currentPoint);
            
            // Connection line
            const lineGeometry = new THREE.BufferGeometry();
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x4CAF50, linewidth: 2 });
            connectionLine = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(connectionLine);
        }
        
        function setupCameraControls() {
            let isMouseDown = false;
            let mouseX = 0;
            let mouseY = 0;
            
            renderer.domElement.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!isMouseDown) return;
                
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera.position);
                
                spherical.theta -= deltaX * 0.01;
                spherical.phi += deltaY * 0.01;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);
                
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            renderer.domElement.addEventListener('wheel', (event) => {
                const scale = event.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(scale);
                camera.position.clampLength(0.5, 10);
                event.preventDefault();
            });
        }
        
        function setupCharts() {
            // Parallel chart
            const parallelCtx = document.getElementById('parallel-chart').getContext('2d');
            parallelChart = new Chart(parallelCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'SSP Values',
                        data: [],
                        borderColor: '#4CAF50',
                        borderWidth: 2,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    scales: {
                        x: { title: { display: true, text: 'Dimension Index' } },
                        y: { title: { display: true, text: 'SSP Value' } }
                    },
                    plugins: { legend: { display: false } }
                }
            });
            
            // Similarity chart
            const similarityCtx = document.getElementById('similarity-chart').getContext('2d');
            similarityChart = new Chart(similarityCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Dot Product',
                            data: [],
                            borderColor: '#2196F3',
                            borderWidth: 2,
                            fill: false
                        },
                        {
                            label: 'Cosine Similarity',
                            data: [],
                            borderColor: '#FF9800',
                            borderWidth: 2,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    scales: {
                        x: { title: { display: true, text: 'Exponent' } },
                        y: { title: { display: true, text: 'Similarity Value' } }
                    }
                }
            });
        }
        
        function generateNewSSP() {
            console.log(`Generating ${currentDimension}D SSP...`);
            currentSSP = SSPUtils.makeGoodUnitary(currentDimension);
            updateAllPoints();
            updateSimilarityChart();
        }
        
        function updateAllPoints() {
            if (allPoints) {
                scene.remove(allPoints);
            }
            
            const points = [];
            for (let exp = -10; exp <= 10; exp += 0.5) {
                const powered = SSPUtils.powerSSP(currentSSP, exp);
                points.push(new THREE.Vector3(
                    powered[0] || 0, 
                    powered[1] || 0, 
                    powered[2] || 0
                ));
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.PointsMaterial({ 
                color: 0x81C784, 
                size: 0.02,
                transparent: true,
                opacity: 0.6
            });
            allPoints = new THREE.Points(geometry, material);
            scene.add(allPoints);
        }
        
        function updateSimilarityChart() {
            const range = parseInt(document.getElementById('similarity-range').value);
            const exponents = [];
            const dotProducts = [];
            const cosineSimilarities = [];
            
            const referenceSSP = SSPUtils.powerSSP(currentSSP, 20);
            
            for (let exp = -range; exp <= range; exp += range / 50) {
                const poweredSSP = SSPUtils.powerSSP(currentSSP, exp);
                const dotProduct = SSPUtils.dotProduct(referenceSSP, poweredSSP);
                const cosineSim = SSPUtils.cosineSimilarity(referenceSSP, poweredSSP);
                
                exponents.push(parseFloat(exp.toFixed(1)));
                dotProducts.push(dotProduct);
                cosineSimilarities.push(cosineSim);
            }
            
            similarityChart.data.labels = exponents;
            similarityChart.data.datasets[0].data = dotProducts;
            similarityChart.data.datasets[1].data = cosineSimilarities;
            similarityChart.update();
        }
        
        function updateVisualization() {
            const exponent = parseFloat(document.getElementById('exponent').value);
            const currentPoweredSSP = SSPUtils.powerSSP(currentSSP, exponent);
            
            // Update 3D
            if (currentPoweredSSP.length >= 3) {
                currentPoint.position.set(
                    currentPoweredSSP[0] || 0,
                    currentPoweredSSP[1] || 0,
                    currentPoweredSSP[2] || 0
                );
                
                const linePoints = [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(
                        currentPoweredSSP[0] || 0, 
                        currentPoweredSSP[1] || 0, 
                        currentPoweredSSP[2] || 0
                    )
                ];
                connectionLine.geometry.setFromPoints(linePoints);
            }
            
            // Update stats
            const norm = SSPUtils.norm(currentPoweredSSP);
            const mean = SSPUtils.mean(currentPoweredSSP);
            const std = SSPUtils.std(currentPoweredSSP);
            
            document.getElementById('norm-value').textContent = norm.toFixed(3);
            document.getElementById('mean-value').textContent = mean.toFixed(3);
            document.getElementById('std-value').textContent = std.toFixed(3);
            
            // Update parallel chart
            const dimensions = Math.min(currentDimension, 20);
            parallelChart.data.labels = Array.from({length: dimensions}, (_, i) => i);
            parallelChart.data.datasets[0].data = currentPoweredSSP.slice(0, dimensions);
            parallelChart.update('none');
        }
        
        function animate() {
            if (isAnimating) {
                animationTime += 0.02 * animationSpeed;
                const exponent = 10 * Math.sin(animationTime);
                
                document.getElementById('exponent').value = exponent;
                document.getElementById('exponent-value').textContent = exponent.toFixed(1);
            }
            
            updateVisualization();
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        
        // Handle resize
        window.addEventListener('resize', () => {
            const container = document.getElementById('threejs-container');
            if (camera && renderer) {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
        });
        
        // Start when ready
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM ready, initializing...");
            setTimeout(init, 100);
        });
    </script>
</body>
</html> 